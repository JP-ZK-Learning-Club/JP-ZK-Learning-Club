---
description: 動作概要
---

# 動作概要(WIP)

zkVM(Zero-Knowledge Virtual Machine)では、証明したい処理(例えばフィボナッチ数列)をゼロ知識証明の回路で記述する代わりに、プログラムを実行するコンピュータそのものを回路で記述することで、任意のプログラムの実行をゼロ知識証明化することができます。

この仕組みによるメリットは、実行を証明したい処理があるとき、circomではなく好きなプログラミング言語で普段と同じように書けばいいという簡潔さです。

## ZKVMの主な構成

zkVMの実装はいくつか方式がありますが、その中でも共通する構成は主に次の4です。
プログラムをコンパイルし、実行トレースを取得し、テーブルをセットし、状態遷移を証明を生成します。

1. Compilation
2. Interpreter Execution
3. Circuit Synthesis
4. Proof Generation

## Compilation

任意のプログラムをVMが対応するISA(命令セット)のELF(Executable and Linkable Format)へコンパイルします。例えば、JoltやSP1はRiscV32IMの実行をターゲットとしていますが、他のzkVMではWASMやEVMなどがターゲットのものもあります。

Risc32IMへのコンパイル可能な言語としてRustがよく使用されますが、他にもllvmをコンパイルのバックエンドとして利用している言語であれば問題なく動くはずです。

## Interpreter Execution

このインタプリタは、RiscVやWASMをシミュレートするもので、ELF内の命令を逐次実行して、レジスタやメモリを更新していきます。
その際、Execution Trace(実行トレース)を取得し、このトレースは次のステップで利用されます。

## Circuit Synthesis

実行プログラム(アッセンブリ)と実行トレースをzkVMのRead-Only-Memory用のテーブルへセットしていきます。この二つのテーブルを参照することで、zkVMは正しい順序で命令が実行されたことを確認することができます。

## Proof Generation

I/Oがない環境では、多くのコンピュータには非決定性がなく、前の状態から次の状態が定ります。zkVMは、ステップnのレジスタ・メモリ・命令の状態から、ステップn+1の状態へ矛盾なく遷移したことを証明することで、上で動くプログラムの実行の正しさを証明します。